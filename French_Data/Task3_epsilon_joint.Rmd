
---
title: "multi - french"
author: "Imperial College"
---


```{r echo = FALSE}
library(knitr)
opts_chunk$set(fig.path='figs/task3/', fig.keep='high',
               dev=c('png'), fig.width=8, fig.height=5, cache=FALSE,
               tidy=FALSE, warning=FALSE, fig.show="asis"
 	       )

library(EpiEstim)
library(epitrix)
library(purrr)
cbind_rep <- function(x,n){
  matrix(x,nrow = length(x), ncol = n, byrow = FALSE)
}

##############################################################################################
##############################################################################################

# wrapper for joint estimate

wrapper_joint_Rt <- function(I, periods,Epi_param, 
                             plot_Rt = TRUE, plot_epsilon_trace = TRUE ){
  
  name_epsi <- c('All',colnames(I[[1]][-1]),paste0('Quarter ',1:4))
  epsi_template <- data.frame(name = name_epsi,
                              med = NA,
                              low = NA,
                              up = NA)
 
  epsilon <- list()
  
  p_R = gamma_mucv2shapescale(mu = Epi_param$mean_prior_Rt,
                              cv = Epi_param$std_prior_Rt/Epi_param$mean_prior_Rt)
  p_epsi = gamma_mucv2shapescale(mu = Epi_param$mean_prior_epsi,
                                 cv = Epi_param$std_prior_epsi/Epi_param$mean_prior_epsi)
  priors <- list(epsilon = p_epsi,
                 R = p_R)
  
  epsilon <- list()
  for (i in 1:(length(I)-1)){
    epsilon[[ paste(names(I)[c(1,i+1)],collapse='_') ]] <- epsi_template
  }
  
  ###################################################################
  ###################################################################
  # estimation across all geo units and time periods
  ###################################################################
  ###################################################################
  
  incid <- array(NA,dim = c(nrow(I[[1]]), 
                            ncol(I[[1]])-1,
                            length(I)) )
  for(i in 1:length(I)){
    incid[,,i] <- as.matrix(I[[i]][,-1])
  }
  Epi_joint <- EpiEstim::estimate_joint(incid = incid, 
                                        si_distr = cbind_rep(x = Epi_param$SI, n = length(I)), 
                                        priors = priors,
                                        mcmc_control = Epi_param$mcmc_control,
                                        t_min = as.integer(periods$intervals[2]),
                                        t_max = as.integer(tail(periods$intervals,n = 1)) )
  
  
  # save results
  for(i in 1:(length(I)-1)){
    epsilon[[i]][1,2:4] <- quantile(Epi_joint$epsilon[i,],c(.5,.025,.975))
  }

  
  # optional plots
  if(plot_epsilon_trace){
    matplot(t(Epi_joint$epsilon))
  }  
  
  Sum_R <- list(median = apply(Epi_joint$R,c(1,2),median),
                  low = apply(Epi_joint$R,c(1,2),quantile,0.025,na.rm=TRUE),
                  high = apply(Epi_joint$R,c(1,2),quantile,0.975,na.rm=TRUE))
  if(plot_Rt){
    layout(matrix(1:4,2,2))
    cols <- RColorBrewer::brewer.pal(5+1,name = 'Dark2')
    cols2 <- yarrr::transparent(cols, trans.val = .9)
    
    
    
    
    for(i in 2:ncol(I[[1]])){
      
      x <- I[[1]]$date
      y <- cbind(Sum_R$median[,i-1],Sum_R$low[,i-1],Sum_R$high[,i-1])
      f <- which(!is.na(Sum_R$median[,i-1]))
      x<-x[f]
      y<-y[f,]
      
      
      plot(x,y[,1],
           xlab = '',ylab = 'Rt',
           type = 'l',col=cols[1],
           main = colnames(I[[1]])[i],
           ylim = c(0, 2) )
      
      
      abline(h = 1,lty=2,col='red3')
      
      polygon(c(x,rev(x)), c(y[,2],rev(y[,3])),
              col = cols2[1],
              border = NA)
    }
  }
  
  ###################################################################
  ###################################################################
  # estimation seperate for each geo units and across the full time period
  ###################################################################
  ###################################################################
  
 
  for(k in 2:ncol(I[[1]])){
    print(colnames(I[[1]])[k])
    
    Epi_joint <- EpiEstim::estimate_joint(incid = incid[,k-1,, drop = FALSE], 
                                        si_distr = cbind_rep(x = Epi_param$SI, n = length(I)), 
                                        priors = priors,
                                        mcmc_control = Epi_param$mcmc_control,
                                        t_min = as.integer(periods$intervals[2]),
                                        t_max = as.integer(tail(periods$intervals,n = 1)) )
    
    for(i in 1:(length(I)-1)){
      epsilon[[i]][k,2:4] <- quantile(Epi_joint$epsilon[i,],c(.5,.025,.975))
    }
    
  }
  
  
  ###################################################################
  ###################################################################
  # estimation seperate for all geo units but for each time period
  ###################################################################
  ###################################################################
  
  Sum_R <- list(Sum_R)
  for(k in 1:(length(periods$intervals)-2)){
    print(name_epsi[1+length(I[[1]])-1+k])
    
    Epi_joint <- EpiEstim::estimate_joint(incid = incid, 
                                        si_distr = cbind_rep(x = Epi_param$SI, n = length(I)), 
                                        priors = priors,
                                        mcmc_control = Epi_param$mcmc_control,
                                        t_min = as.integer(periods$intervals[1+k]),
                                        t_max = as.integer(periods$intervals[1+k+1]) )
    
    Sum_R[[k+1]] <- list(median = apply(Epi_joint$R,c(1,2),median),
                       low = apply(Epi_joint$R,c(1,2),quantile,0.025,na.rm=TRUE),
                       high = apply(Epi_joint$R,c(1,2),quantile,0.975,na.rm=TRUE))
    
    for(i in 1:(length(I)-1)){
      epsilon[[i]][1+length(I[[1]])-1+k,2:4] <- quantile(Epi_joint$epsilon[i,],c(.5,.025,.975))
    }
    
  }
  
  return(list(epsilon = epsilon, Sum_R = Sum_R))
}

```

# load data

```{r}

Epi_param <- readRDS('Rdata/Epi_param.rds')

I_fr <- readRDS(file = 'Rdata/I_fr.rds')
I_UK1 <- readRDS(file = 'Rdata/I_UK1.rds')
I_UK2 <- readRDS(file = 'Rdata/I_UK2.rds')

periods <- readRDS(file = 'Rdata/periods.rds')

```


# run joint epiesptim to get epsilon


```{r,fr}

Jestim_fr <- wrapper_joint_Rt(I = I_fr, 
                               periods = periods$periods_fr,
                               Epi_param = Epi_param, 
                               plot_Rt = TRUE,
                               plot_epsilon_trace = TRUE)


```



```{r,UK1}

Jestim_UK1 <- wrapper_joint_Rt(I = I_UK1, 
                               periods = periods$periods_UK1,
                               Epi_param = Epi_param, 
                               plot_Rt = TRUE,
                               plot_epsilon_trace = TRUE)


```



```{r,UK2}

Jestim_UK2 <- wrapper_joint_Rt(I = I_UK2, 
                               periods = periods$periods_UK2,
                               Epi_param = Epi_param, 
                               plot_Rt = TRUE,
                               plot_epsilon_trace = TRUE)


```



# save

```{r}

saveRDS(object = Jestim_fr, file = 'Rdata/Jestim_fr.rds')
saveRDS(object = Jestim_UK1, file = 'Rdata/Jestim_UK1.rds')
saveRDS(object = Jestim_UK2, file = 'Rdata/Jestim_UK2.rds')


```
## Estimates by week

```{r}

incid <- array(NA, dim = c(nrow(I_UK1[[1]]), 
                           ncol(I_UK1[[1]]) - 1,
                           length(I_UK1)))
for(i in 1:length(I_UK1)){
  incid[,,i] <- as.matrix(I_UK1[[i]][,-1])
}

## start estimating at 3 weeks
t_min <- 14L
t_max <- seq(from = 14, to = nrow(I_UK1[[1]]), by = 7)
priors <- default_priors()
nregions <- 7
## Do this by region 
estimates <- map(
  t_max, function(tmax) {
    out <- map(1:nregions, function(region) {
      estimate_joint(
        incid = incid[, region, , drop = FALSE],
        si_distr = cbind_rep(x = Epi_param$SI, n = length(I_UK1)), 
        mcmc_control = Epi_param$mcmc_control,
        priors = priors,
        t_min = t_min,
        t_max = as.integer(tmax)
      )
    })
    names(out) <- names(I_UK1[[1]])[-1]
    out
  }
)

names(estimates) <- I_UK1[[1]][["date"]][t_max]

eps_estimates <- map_dfr(
  estimates, function(x) {
    map_dfr(
      x, function(y) {
        out <- apply(
          y[["epsilon"]], 1, quantile,
          prob = c(0.025, 0.5, 0.975)
        )
        out <- data.frame(out)
        names(out) <- "Alpha"
        out <- tibble::rownames_to_column(out, "qntl")
        out <- tidyr::gather(out, variant, epsilon, -qntl)
        tidyr::spread(out, qntl, epsilon)        
      }, .id = "NHS Region"
    )
  }, .id = "date"
)

p <- ggplot(eps_estimates) +
  geom_point(aes(date, `50%`)) +
  geom_linerange(aes(x = date, ymin = `2.5%`, ymax = `97.5%`)) +
  facet_wrap(~`NHS Region`, scales = "free_y") +
  expand_limits(y = c(0, NA)) +
  geom_hline(
    yintercept = 1, linetype = "dashed"
  ) +
  ylab("Transmission Advantage") +
  theme_minimal() +
  theme(
    text = element_text(size = 12),
    axis.title.x = element_blank(),
    axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0)
  )

ggsave("uk_using_by_regions.pdf", p)

total_incid <- data.frame(
  date = I_UK1$wild[["date"]],
  wild = apply(I_UK1$wild[, -1], 1, sum),
  alpha = apply(I_UK1$alpha[, -1], 1, sum)
)
total_incid$cuml_wild <- cumsum(total_incid$wild)
total_incid$cuml_alpha <- cumsum(total_incid$alpha)
total_incid$alpha_prop <- total_incid$cuml_alpha / (total_incid$cuml_alpha + total_incid$cuml_wild)
eps_estimates$date <- as.Date(eps_estimates$date)
x <- left_join(eps_estimates, total_incid)

p <- ggplot(x) +
  geom_point(aes(alpha_prop, `50%`)) +
  geom_linerange(aes(x = alpha_prop, ymin = `2.5%`, ymax = `97.5%`)) +
  facet_wrap(~variant, ncol = 1, scales = "free_y") +
  expand_limits(y = c(0, NA)) +
  geom_hline(
    yintercept = 1, linetype = "dashed"
  ) +
  scale_x_continuous(
    labels = scales::percent
  ) + 
  xlab("Proportion of Alpha") +
  ylab("Transmission Advantage") +
  ##theme_minimal() +
  theme(
    text = element_text(size = 16)
  )
p2 <- p + ggforce::facet_zoom(xlim = c(0, 0.1))

ggsave("uk_using_all_regions_alpha_prop.pdf", p2)

```
## Leave one out

```{r}

incid <- array(NA, dim = c(nrow(I_fr[[1]]), 
                           ncol(I_fr[[1]]) - 1,
                           length(I_fr)))
for(i in 1:length(I_fr)){
  incid[,,i] <- as.matrix(I_fr[[i]][,-1])
}

## start estimating at 3 weeks
t_min <- 7L
t_max <- seq(from = 14, to = 102, by = 7)
priors <- default_priors()
leave_out <- 1:18
names(leave_out) <-  paste(
  "Leave out", names(I_fr[[1]])[-1]
)

estimates <- map(
  t_max, function(tmax) {
    map(
      leave_out, function(leave) {
        x <- incid[, -leave, , drop = FALSE]
        estimate_joint(
          incid = x, 
          si_distr = cbind_rep(x = Epi_param$SI, n = length(I_fr)), 
          mcmc_control = Epi_param$mcmc_control,
          priors = priors,
          t_min = t_min,
          t_max = as.integer(tmax)
        )
      }
    )
  }
)

names(estimates) <- I_fr[[1]][["date"]][t_max]

eps_estimates <- map_dfr(
  estimates, function(x) {
    map_dfr(x, function(y) {
      out <- apply(
        y[["epsilon"]], 1, quantile,
        prob = c(0.025, 0.5, 0.975)
      )
      out <- data.frame(out)
      names(out) <- c("Alpha", "Beta/Gamma")
      out <- tibble::rownames_to_column(out, "qntl")
      out <- tidyr::gather(out, variant, epsilon, -qntl)
      tidyr::spread(out, qntl, epsilon)
    }, .id = "Leave out"
    )
  }, .id = "date"
)
x <- eps_estimates[eps_estimates$date == "2021-03-03", ]
p <- ggplot(x) +
  geom_point(aes(date, `50%`)) +
  geom_linerange(aes(x = date, ymin = `2.5%`, ymax = `97.5%`)) +
  ggforce::facet_grid_paginate(~variant, scales = "free_y", nrow = 3, ncol = 1, page = ) +
  expand_limits(y = c(0, NA)) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 0, vjust = 0)
  )

ggsave("french_using_all_data.pdf", p)

```

## Joint naive estimates from our new method

## Tables for the supplementary

```{r}
## Throwaway function to make pretty data.frame
pretty_table <- function(x) {
  x <- mutate_if(x, is.numeric, round, 2)
  x <- na.omit(x)
  x$formatted <- glue::glue("{x$med} ({x$low} - {x$up})")
  x <- x[, c("name", "formatted")]
  colnames(x) <- c("Region/Time-period", "Median (95\\% CrI)")
  x
}

combine_estimates <- function(naive, joint) {
  naive <- pretty_table(naive)
  joint <- pretty_table(joint)
  naive$method <- "Naive"
  joint$method <- "Joint-EpiEstim"
  both <- rbind(joint, naive)
  tidyr::spread(both, method, `Median (95\\% CrI)`)
}

```


```{r}
## Task 2 outputs
naive <- naive_epsilon_UK1$sum_epsilon$wild_alpha
joint <- Jestim_UK1[["epsilon"]][["wild_alpha"]]
x <- combine_estimates(naive, joint)
stargazer::stargazer(x[, c(1, 3, 2)], summary = FALSE)


naive <- naive_epsilon_UK2$sum_epsilon$alpha_delta
joint <- Jestim_UK2[["epsilon"]][["alpha_delta"]]
x <- combine_estimates(naive, joint)
stargazer::stargazer(x[, c(1, 3, 2)], summary = FALSE)


naive <- naive_epsilon_fr$sum_epsilon$wild_alpha
joint <- Jestim_fr[["epsilon"]][["wild_alpha"]]
x <- combine_estimates(naive, joint)
stargazer::stargazer(x[, c(1, 3, 2)], summary = FALSE)


naive <- naive_epsilon_fr$sum_epsilon[["wild_beta/gamma"]]
joint <- Jestim_fr[["epsilon"]][["wild_beta/gamma"]]
x <- combine_estimates(naive, joint)
stargazer::stargazer(x[, c(1, 3, 2)], summary = FALSE)



```
